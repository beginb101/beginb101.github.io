---
layout: post
title: React 리덕스 미들웨어
description: >
  2022-10-23-React 리덕스 미들웨어를 통한 비동기 작업 관리
hide_description: false
category: dailydev
---

- Table of Contents
{:toc} 

리액트 웹 애플리케이션에서 API 서버를 연동할 때는 API 요청에 대한 상태도 잘 관리해야 한다.

- 요청이 시작되었을때는 로딩
- 요청이 성공 or 실패시 로딩이 끝났음을 명시
- 요청이 성공하면 서버에서 받아 온 응답에 대한 상태를 관리
- 요청이 실패하면 서버에서 반환한 에러에 대한 상태를 관리

위와 같이 관리해야 한다. 리덕스를 사용하면 이러한 비동기 작업을 미들웨어를 사용하여 매우 효율적이고 편하게 상태관리를 할 수 있다.

## 작업 환경 준비 
프로젝트 생성 및 라이브러리 추가
```bash
$ yarn create react-app learn-redux-middleware

$ yarn add redux react-redux redux-actions
```

리덕스 코드 준비
```javascript
//modules/counter.js
import { createAction, handleActions } from "redux-actions";

const INCREASE = 'counter/INCREASE';
const DECREASE = 'counter/DECREASE';

export const increase = createAction(INCREASE);
export const decrease = createAction(DECREASE);

const initialState = 0; 
//상태는 꼭 객체일 필요가 없다. 
//숫자도 작동한다.

const counter = handleActions(
  {
    [INCREASE]: state => state + 1,
    [DECREASE]: state => state - 1
  },
  initialState
);

export default counter;
```

루트 리듀서 생성
```javascript
//modules/index.js
import { combineReducers } from 'redux';
import counter from './counter';

const rootReducer = combineReducers({
  counter
});

export default rootReducer;
```

리듀서 적용
```javascript
//index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';
import { configureStore } from '@reduxjs/toolkit';
import { Provider } from 'react-redux';
import rootReducer from './modules';

const store = configureStore({
  reducer : rootReducer
});

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <Provider store={store}>
      <App />
    </Provider>
  </React.StrictMode>
);

reportWebVitals();
```

카운터 컴포넌트 컴포넌트 생성
```javascript
//components/Counter.js
import React from 'react';

const Counter = ({ onIncrease, onDecrease, number }) => {
  return (
    <div>
      <h1>{number}</h1>
      <button onClick={onIncrease}>+1</button>
      <button onClick={onDecrease}>-1</button>
    </div>
  );
};

export default Counter;
```

카운터 컨테이너 컴포넌트 생성
```javascript
//containers/CounterContainer.js
import React from 'react';
import { connect } from 'react-redux';
import { increase, decrease } from '../modules/counter';
import Counter from '../components/Counter';


const CounterContainer = ({ number, increase, decrease }) => {
  return (
    <Counter number={number} 
            onIncrease={increase} 
            onDecrease={decrease} 
    />
  );
};

export default connect(
  state => ({
    number: state.counter
  }),
  {
    increase,
    decrease
  }
)(CounterContainer);
```
작동 확인
```javascript
//App.js
import React from 'react';
import CounterContainer from './containers/CounterContainer';

const App = () => {
  return (
    <div>
      <CounterContainer />
    </div>
  );
};

export default App;
```

![600X480](/assets/img/blog/476.jpg)
<br> 카운터 작동 확인
{:.figure}

## 미들웨어란?
리덕스 미들웨어는 액션을 디스패치했을 때 리듀서에서 이를 처리하기에 앞서 사전에 지정된 작업들을 실행한다.

![600X480](/assets/img/blog/476_2.jpg)
<br> 미들웨어
{:.figure}

미들웨어가 할 수 있는 작업

- 전달받은 액션을 단순히 콘솔에 기록
- 전달받은 액션 정보를 기반으로 액션을 취소
- 전달받은 액션 정보를 기반으로 다른 종류의 액션을 추가로 디스패치

## 미들웨어 만들기
실무에서 미들웨어를 직접 만들어서 사용할 일은 많지 않다. 보통 다른 개발자가 만들어 놓은 미들웨어를 사용하면 되기 때문이다. 하지만 미들웨어가 어떻게 작동하는지 이해하려면 직접 만들어 보는 것이 가장 효과적이다. 나중에 원하는 미들웨어를 찾을 수 없을 때는 상황에 따라 직접 만들거나 기존 미들웨어들을 커스터마이징하여 사용할 수 있는 상황도 있기때문이다. 액션이 디스패치될 때마다 액션의 정보와 액션이 디스패치되 전후의 상태를 콘솔에 보여주는 로깅 미들웨어를 만들어 본다.

```javascript
const loggerMiddleware = store => next => action => {
    // 미들웨어 기본 구조
}; 
  
export default loggerMiddleware;
```

미들웨어는 결국 함수를 반환하는 함수를 반환하는 함수이다.

- store 파라미터는 리덕스 스토어 인스턴스
- action 파라미터는 디스패치된 액션
- next 파라미터는 함수 형태이며, store.dispatch와 비슷한 역활이다.
차이점은 next(action)을 호출하면 그다음 처리해야 할 미들웨어에게 액션을 넘겨주고, 만약 그 다음 미들웨어가 없다면 리듀서에게 액션을 넘겨준다는 것이다.


![600X480](/assets/img/blog/478.jpg)
<br> store.dispatch vs. next
{:.figure}

미들웨어 내부에서 store.dispatch를 사용하면 첫 번째 미들웨어부터 다시 처리한다. 만약 미들웨어에서 next를 사용하지 않으면 액션이 리듀서에 전달되지 않는다. 즉, 액션이 무시된다.<br>

이제 만들 미들웨어는 다음 정보를 순차적으로 콘솔에 보여 줍니다.

- 1. 이전 상태
- 2. 액션 정보
- 3. 새로워진 상태

```javascript
//lib/loggerMiddleware.js
const loggerMiddleware = store => next => action => {
    console.group(action && action.type); 
    // 액션 타입으로 log를 그룹화함
    console.log('이전 상태', store.getState());
    console.log('액션', action);
    next(action); 
    // 다음 미들웨어 혹은 리듀서에게 전달
    console.log('다음 상태', store.getState());
     // 업데이트된 상태
    console.groupEnd(); 
    // 그룹 끝
  };  
  
  export default loggerMiddleware;
```
 
미들웨어 적용
```javascript
//index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';
import { configureStore } from '@reduxjs/toolkit';
import { Provider } from 'react-redux';
import rootReducer from './modules';
import loggerMiddleware from './lib/loggerMiddleware';

const store = configureStore({
  reducer : rootReducer,
  middleware: [loggerMiddleware]
});

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <Provider store={store}>
      <App />
    </Provider>
  </React.StrictMode>
);

reportWebVitals();
```

![600X480](/assets/img/blog/479.jpg)
<br> 직접만든 미들웨어
{:.figure}


## 참고 문헌

[리액트를 다루는 기술](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&linkClass=&barcode=9791160508796)