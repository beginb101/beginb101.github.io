---
layout: post
title: React 리덕스 미들웨어
description: >
  2022-10-23-React 리덕스 미들웨어를 통한 비동기 작업 관리
hide_description: false
category: dailydev
---

- Table of Contents
{:toc} 

리액트 웹 애플리케이션에서 API 서버를 연동할 때는 API 요청에 대한 상태도 잘 관리해야 한다.

- 요청이 시작되었을때는 로딩
- 요청이 성공 or 실패시 로딩이 끝났음을 명시
- 요청이 성공하면 서버에서 받아 온 응답에 대한 상태를 관리
- 요청이 실패하면 서버에서 반환한 에러에 대한 상태를 관리

위와 같이 관리해야 한다. 리덕스를 사용하면 이러한 비동기 작업을 미들웨어를 사용하여 매우 효율적이고 편하게 상태관리를 할 수 있다.

## 작업 환경 준비 
프로젝트 생성 및 라이브러리 추가
```bash
$ yarn create react-app learn-redux-middleware

$ yarn add redux react-redux redux-actions
```

리덕스 코드 준비
```javascript
//modules/counter.js
import { createAction, handleActions } from "redux-actions";

const INCREASE = 'counter/INCREASE';
const DECREASE = 'counter/DECREASE';

export const increase = createAction(INCREASE);
export const decrease = createAction(DECREASE);

const initialState = 0; 
//상태는 꼭 객체일 필요가 없다. 
//숫자도 작동한다.

const counter = handleActions(
  {
    [INCREASE]: state => state + 1,
    [DECREASE]: state => state - 1
  },
  initialState
);

export default counter;
```

루트 리듀서 생성
```javascript
//modules/index.js
import { combineReducers } from 'redux';
import counter from './counter';

const rootReducer = combineReducers({
  counter
});

export default rootReducer;
```

리듀서 적용
```javascript
//index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';
import { configureStore } from '@reduxjs/toolkit';
import { Provider } from 'react-redux';
import rootReducer from './modules';

const store = configureStore({
  reducer : rootReducer
});

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <Provider store={store}>
      <App />
    </Provider>
  </React.StrictMode>
);

reportWebVitals();
```

카운터 컴포넌트 컴포넌트 생성
```javascript
//components/Counter.js
import React from 'react';

const Counter = ({ onIncrease, onDecrease, number }) => {
  return (
    <div>
      <h1>{number}</h1>
      <button onClick={onIncrease}>+1</button>
      <button onClick={onDecrease}>-1</button>
    </div>
  );
};

export default Counter;
```

카운터 컨테이너 컴포넌트 생성
```javascript
//containers/CounterContainer.js
import React from 'react';
import { connect } from 'react-redux';
import { increase, decrease } from '../modules/counter';
import Counter from '../components/Counter';


const CounterContainer = ({ number, increase, decrease }) => {
  return (
    <Counter number={number} 
            onIncrease={increase} 
            onDecrease={decrease} 
    />
  );
};

export default connect(
  state => ({
    number: state.counter
  }),
  {
    increase,
    decrease
  }
)(CounterContainer);
```
작동 확인
```javascript
//App.js
import React from 'react';
import CounterContainer from './containers/CounterContainer';

const App = () => {
  return (
    <div>
      <CounterContainer />
    </div>
  );
};

export default App;
```

![600X480](/assets/img/blog/476.jpg)
<br> 카운터 작동 확인
{:.figure}

## 미들웨어란?
리덕스 미들웨어는 액션을 디스패치했을 때 리듀서에서 이를 처리하기에 앞서 사전에 지정된 작업들을 실행한다.

![600X480](/assets/img/blog/476_2.jpg)
<br> 미들웨어
{:.figure}

미들웨어가 할 수 있는 작업

- 전달받은 액션을 단순히 콘솔에 기록
- 전달받은 액션 정보를 기반으로 액션을 취소
- 전달받은 액션 정보를 기반으로 다른 종류의 액션을 추가로 디스패치

## 미들웨어 만들기
실무에서 미들웨어를 직접 만들어서 사용할 일은 많지 않다. 보통 다른 개발자가 만들어 놓은 미들웨어를 사용하면 되기 때문이다. 하지만 미들웨어가 어떻게 작동하는지 이해하려면 직접 만들어 보는 것이 가장 효과적이다. 나중에 원하는 미들웨어를 찾을 수 없을 때는 상황에 따라 직접 만들거나 기존 미들웨어들을 커스터마이징하여 사용할 수 있는 상황도 있기때문이다. 액션이 디스패치될 때마다 액션의 정보와 액션이 디스패치되 전후의 상태를 콘솔에 보여주는 로깅 미들웨어를 만들어 본다.

```javascript
const loggerMiddleware = store => next => action => {
    // 미들웨어 기본 구조
}; 
  
export default loggerMiddleware;
```

미들웨어는 결국 함수를 반환하는 함수를 반환하는 함수이다.

- store 파라미터는 리덕스 스토어 인스턴스
- action 파라미터는 디스패치된 액션
- next 파라미터는 함수 형태이며, store.dispatch와 비슷한 역활이다.
차이점은 next(action)을 호출하면 그다음 처리해야 할 미들웨어에게 액션을 넘겨주고, 만약 그 다음 미들웨어가 없다면 리듀서에게 액션을 넘겨준다는 것이다.


![600X480](/assets/img/blog/478.jpg)
<br> store.dispatch vs. next
{:.figure}

미들웨어 내부에서 store.dispatch를 사용하면 첫 번째 미들웨어부터 다시 처리한다. 만약 미들웨어에서 next를 사용하지 않으면 액션이 리듀서에 전달되지 않는다. 즉, 액션이 무시된다.<br>

이제 만들 미들웨어는 다음 정보를 순차적으로 콘솔에 보여 줍니다.

- 1. 이전 상태
- 2. 액션 정보
- 3. 새로워진 상태

```javascript
//lib/loggerMiddleware.js
const loggerMiddleware = store => next => action => {
    console.group(action && action.type); 
    // 액션 타입으로 log를 그룹화함
    console.log('이전 상태', store.getState());
    console.log('액션', action);
    next(action); 
    // 다음 미들웨어 혹은 리듀서에게 전달
    console.log('다음 상태', store.getState());
     // 업데이트된 상태
    console.groupEnd(); 
    // 그룹 끝
  };  
  
  export default loggerMiddleware;
```
 
미들웨어 적용
```javascript
//index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';
import { configureStore } from '@reduxjs/toolkit';
import { Provider } from 'react-redux';
import rootReducer from './modules';
import loggerMiddleware from './lib/loggerMiddleware';

const store = configureStore({
  reducer : rootReducer,
  middleware: [loggerMiddleware]
});

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <Provider store={store}>
      <App />
    </Provider>
  </React.StrictMode>
);

reportWebVitals();
```

![600X480](/assets/img/blog/479.jpg)
<br> 직접만든 미들웨어
{:.figure}

## redux-logger 사용하기
직접 만든 loggerMiddleware 보다 더 잘만들어진 redux-logger를 설치해보자. yarn add redux-logger 명령어를 통해 설치하고 index.js를 수정한다

```javascript
//index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';
import { configureStore } from '@reduxjs/toolkit';
import { Provider } from 'react-redux';
import rootReducer from './modules';
//import loggerMiddleware from './lib/loggerMiddleware';
import { createLogger } from 'redux-logger';

const logger = createLogger();
const store = configureStore({
  reducer : rootReducer,
  middleware: [logger]
});

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <Provider store={store}>
      <App />
    </Provider>
  </React.StrictMode>
);

reportWebVitals();
```

![600X480](/assets/img/blog/481.jpg)
<br> redux-logger
{:.figure}

이처럼 이미 완성된 오픈소스 미들웨어를 라이브러리로 설치해서 사용하는 경우가 많다.

## 비동기 작업을 처리하는 미들웨어 사용
비동기 작업을 처리하는 미들웨어는 다양하다. 그 중 redux-thunk, redux-saga: redux-thunk를 사용해본다.

- redux-thunk : 비동기 작업을 처리할 때 가장 많이 사용하는 미들웨어. 객체가 아닌 함수 형태의 액션을 디스패치할 수 있게 해준다.
- redux-saga: redux-thunk : 특정 액션이 디스패치되었을 때 정해진 로직에 따라 다른 액션을 디스패치시키는 규칙을 작성하여 비동기 작업을 처리할 수 있게 해준다.

## redux-thunk
Thunk는 특정 작업을 나중에 할 수 있도록 미루기 위해 함수 형태로 감싼 것. 
redux-thunk 라이브러리를 사용하면 thunk 함수를 만들어서 디스패치할 수 있다. 
그러면 리덕스 미들웨어가 그 함수를 전달받아 store의 dispatch와 getState를 파라미터로 넣어서 호출해 준다.

## redux-thunk 미들웨어 적용
스토어를 만들 때 redux-thunk를 적용
```javascript
//index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';
import { configureStore } from '@reduxjs/toolkit';
import { Provider } from 'react-redux';
import rootReducer from './modules';
//import loggerMiddleware from './lib/loggerMiddleware';
import { createLogger } from 'redux-logger';
import ReduxThunk from 'redux-thunk';

const logger = createLogger();
const store = configureStore({
  reducer : rootReducer,
  middleware: [logger, ReduxThunk]
});

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <Provider store={store}>
      <App />
    </Provider>
  </React.StrictMode>
);

reportWebVitals();
```
Thunk 생성 함수 만들기<br>
redux-thunk는 액션 생성 함수에서 일반 액션 객체를 반환하는 대신에 함수를 반환한다. 
increaseAsync와 decreaseAsync 함수를 만들어 카운터 값을 비동기적으로 변경시켜 본다.
```javascript
//modules/counter.js
import { createAction, handleActions } from "redux-actions";

const INCREASE = 'counter/INCREASE';
const DECREASE = 'counter/DECREASE';

export const increase = createAction(INCREASE);
export const decrease = createAction(DECREASE);

// 1초 뒤에 increase 혹은 decrease 함수를 디스패치함
export const increaseAsync = () => dispatch => {
    setTimeout(() => {
      dispatch(increase());
    }, 1000);
};
export const decreaseAsync = () => dispatch => {
    setTimeout(() => {
      dispatch(decrease());
    }, 1000);
};

const initialState = 0; 
//상태는 꼭 객체일 필요가 없다. 
//숫자도 작동한다.

const counter = handleActions(
  {
    [INCREASE]: state => state + 1,
    [DECREASE]: state => state - 1
  },
  initialState
);

export default counter;
```

액션 생성 함수도 변경
```javascript
//container/CounterContainer.js
import React from 'react';
import { connect } from 'react-redux';
import { increaseAsync, decreaseAsync } from '../modules/counter';
import Counter from '../components/Counter';


const CounterContainer = ({ number, increaseAsync, decreaseAsync }) => {
  return (
    <Counter number={number} 
            onIncrease={increaseAsync} 
            onDecrease={decreaseAsync} 
    />
  );
};

export default connect(
  state => ({
    number: state.counter
  }),
  {
    increaseAsync,
    decreaseAsync
  }
)(CounterContainer);
```

![600X480](/assets/img/blog/486.jpg)
<br> redux-thunk 적용
{:.figure}

처음 디스패치되는 액션은 함수 형태이고, 두 번째 액션은 객체 형태이다.

## 웹 요청 비동기 작업 처리하기
웹 요청을 연습하기 위해 JSONPlaceholder에서 제공되는 가짜 API를 사용

```bash
$ yarn add axios
```
API를 호출할 때는 주로 Promise 기반 웹 클라이언트인 axios를 사용한다.
우선 API를 모두 함수화 한다.

```javascript
//lib/api.js
import axios from 'axios';

export const getPost = id =>
  axios.get(`https://jsonplaceholder.typicode.com/posts/${id}`);

export const getUsers = id =>
  axios.get(`https://jsonplaceholder.typicode.com/users`);
```

API를 사용하여 데이터를 받아와 상태를 관리할 sample 리듀서 생성
```javascript
//modules/sample.js
import { handleActions } from 'redux-actions';
import * as api from '../lib/api';

// 액션 타입을 선언
// 한 요청당 세 개를 만들어야 한다1.
const GET_POST = 'sample/GET_POST';
const GET_POST_SUCCESS = 'sample/GET_POST_SUCCESS';
const GET_POST_FAILURE = 'sample/GET_POST_FAILURE';

const GET_USERS = 'sample/GET_USERS';
const GET_USERS_SUCCESS = 'sample/GET_USERS_SUCCESS';
const GET_USERS_FAILURE = 'sample/GET_USERS_FAILURE';

// thunk 함수 생성
// thunk 함수 내부에서는 시작할 때, 성공했을 때, 
// 실패했을 때 다른 액션을 디스패치한다.
export const getPost = id => async dispatch => {
  dispatch({ type: GET_POST }); // 요청을 시작한 것을 알림
  try {
    const response = await api.getPost(id);
    dispatch({
      type: GET_POST_SUCCESS,
      payload: response.data
    }); // 요청 성공
  } catch (e) {
    dispatch({
      type: GET_POST_FAILURE,
      payload: e,
      error: true
    }); // 에러 발생
    throw e; // 나중에 컴포넌트단에서 에러를 조회할 수 있게 해 줌
  }
};

export const getUsers = () => async dispatch => {
  dispatch({ type: GET_USERS }); // 요청을 시작한 것을 알림
  try {
    const response = await api.getUsers();
    dispatch({
      type: GET_USERS_SUCCESS,
      payload: response.data
    }); // 요청 성공
  } catch (e) {
    dispatch({
      type: GET_USERS_FAILURE,
      payload: e,
      error: true
    }); // 에러 발생
    throw e; // 나중에 컴포넌트단에서 에러를 조회할 수 있게 해 줌
  }
};
// 초기 상태를 선언
// 요청의 로딩 중 상태는 loading이라는 객체에서 관리
const initialState = {
  loading: {
    GET_POST: false,
    GET_USERS: false
  },
  post: null,
  users: null
};

const sample = handleActions(
  {
    [GET_POST]: state => ({
      ...state,
      loading: {
        ...state.loading,
        GET_POST: true // 요청 시작
      }
    }),
    [GET_POST_SUCCESS]: (state, action) => ({
      ...state,
      loading: {
        ...state.loading,
        GET_POST: false // 요청 완료
      },
      post: action.payload
    }),
    [GET_POST_FAILURE]: (state, action) => ({
      ...state,
      loading: {
        ...state.loading,
        GET_POST: false // 요청 완료
      }
    }),
    [GET_USERS]: state => ({
      ...state,
      loading: {
        ...state.loading,
        GET_USERS: true // 요청 시작
      }
    }),
    [GET_USERS_SUCCESS]: (state, action) => ({
      ...state,
      loading: {
        ...state.loading,
        GET_USERS: false // 요청 완료
      },
      users: action.payload
    }),
    [GET_USERS_FAILURE]: (state, action) => ({
      ...state,
      loading: {
        ...state.loading,
        GET_USERS: false // 요청 완료
      }
    })
  },
  initialState
);

export default sample;
```

프레젠테이셔널 컴포넌트 작성
```javascript
//components/Sample.js
import React from 'react';

const Sample = ({ loadingPost, loadingUsers, post, users }) => {
  return (
    <div>
      <section>
        <h1>포스트</h1>
        {loadingPost && '로딩 중...'}
        {!loadingPost && post && (
          <div>
            <h3>{post.title}</h3>
            <h3>{post.body}</h3>
          </div>
        )}
      </section>
      <hr />
      <section>
        <h1>사용자 목록</h1>
        {loadingUsers && '로딩 중...'}
        {!loadingUsers && users && (
          <ul>
            {users.map(user => (
              <li key={user.id}>
                {user.username} ({user.email})
              </li>
            ))}
          </ul>
        )}
      </section>
    </div>
  );
};

export default Sample;
```

데이터를 불러와서 렌더링해 줄 때는 유효성 검사를 해 주는 것이 중요하다. 예를 들어 post &&를 사용하면 post 객체가 유효할 때만 그 내부의 post.title 혹은 post.body 값을 보여 준다. 만약 데이터가 없는 상태라면 post.title을 조회하려고 할 때 자바스크립트 오류가 발생하니 반드시 유효성을 검사해 주어야 한다.
users도 마찬가지 이다.  컨테이너 컴포넌트를 만든다.
```javascript
//containers/SampleContainer.js
import React from 'react';
import { connect } from 'react-redux';
import Sample from '../components/Sample';
import { getPost, getUsers } from '../modules/sample';

const { useEffect } = React;
const SampleContainer = ({
  getPost,
  getUsers,
  post,
  users,
  loadingPost,
  loadingUsers
}) => {
  // 클래스 형태 컴포넌트였다면 componentDidMount
  useEffect(() => {
    getPost(1);
    getUsers(1);
  }, [getPost, getUsers]);
  return (
    <Sample
      post={post}
      users={users}
      loadingPost={loadingPost}
      loadingUsers={loadingUsers}
    />
  );
};

export default connect(
  ({ sample }) => ({
    post: sample.post,
    users: sample.users,
    loadingPost: sample.loading.GET_POST,
    loadingUsers: sample.loading.GET_USERS
  }),
  {
    getPost,
    getUsers
  }
)(SampleContainer);
```

SampleContainer 렌더링
```javascript
//App.js
import React from 'react';
import SampleContainer from './containers/SampleContainer';

const App = () => {
  return (
    <div>
      <SampleContainer />
    </div>
  );
};

export default App;
```

![600X480](/assets/img/blog/494.jpg)
<br> 데이터 요청 성공
{:.figure}

## 리팩토링
API를 요청해야 할 때마다 17줄 정도 되는 thunk 함수를 작성하는 것과 로딩 상태를 리듀서에서 관리하는 작업은 귀찮을 뿐 아니라 코드도 길어지게 만든다. 
그러므로 반복되는 로직을 따로 분리하여 코드의 양을 줄여 본다.


## 참고 문헌

[리액트를 다루는 기술](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&linkClass=&barcode=9791160508796)